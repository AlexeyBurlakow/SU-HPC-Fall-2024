Задание: реализовать простой генетический алгоритм для нахождения приближения функции.


Входные данные:


Набор точек на поверхности (500–1000); 

Размер популяции P (1000–2000);

Em, Dm — среднее и дисперсия для мутации, чтобы генерировать случайное количество мутированных генов; 

maxIter — максимальное количество поколений, maxConstIter — максимальное количество поколений с постоянным значением наилучшей пригодности.

Начальная популяция задается случайным образом.


Генетический алгоритма был реализован в 6 этапов:


1. Инициализация популяции.
   Функция initialize_population создает начальную популяцию случайных многочленов с помощью случайных значений коэффициентов для каждого индивида. Размер популяции задается параметром population_size.
   
2. Оценка пригодности.
   Функция fitness вычисляет ошибку аппроксимации для каждого индивида. Для каждого многочлена (индивида) проверяется, насколько хорошо он аппроксимирует данные.
   
3. Кроссовер.
   Функция crossover выполняет операцию скрещивания двух случайных родителей, создавая два новых потомка. Это делается путем обмена генами между родителями в случайной точке.
   
4. Мутация. 
   Функция mutate модифицирует гены в индивидах случайным образом. Количество мутированных генов определяется нормальным распределением.
   
5. Селекция.
    Функция selection отбирает лучших индивидов на основе их пригодности. Индивиды с наименьшей ошибкой остаются в популяции, а остальные удаляются.
   
6. Ранняя остановка.
    Если за несколько поколений не происходит улучшений в лучшем индивиде, алгоритм прекращает выполнение.

Результаты:

Generation 50/1000, Best Fitness: 109483.570395

Ранняя остановка из-за отсутствия улучшений.

Время обработки на GPU: 27.21 секунд

Лучшие параметры многочлена: [ 0.29637436 -0.11986063  0.62293802  0.00851344  0.00500828]

Лучшее значение пригодности: 109483.57039544417

Число поколений: 63
![](https://github.com/AlexeyBurlakow/SU-HPC-Fall-2024/blob/main/Genetic_algorithm/image/1.png)
